import chokidar from 'chokidar';
import fg from 'fast-glob';
import matter from 'gray-matter';
import fs from 'node:fs/promises';
import path from 'node:path';
import { convertTocForDocsComponent, getTableOfContents } from './toc';

export type MdxPagesOptions = {
    postsDir?: string; // source mdx: default resources/js/posts
    pagesOutDir?: string; // generated pages: default resources/js/pages/docs
    templatePath?: string; // wrapper: default resources/js/layouts/docs-layout.tsx
    manifestPath?: string; // php manifest: default bootstrap/cache/mdx.json
    pageExt?: 'tsx' | 'jsx'; // default tsx
    toSlug?: (absFile: string, postsDirAbs: string) => string; // slug builder
};

function norm(p: string) {
    return p.replace(/\\/g, '/');
}
function kebab(s: string) {
    return s
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
}

function slugify(relPath: string) {
    return relPath
        .replace(/\.mdx$/i, '')
        .split('/')
        .map(kebab)
        .join('/');
}

export default function inertiaMdxPages(user: MdxPagesOptions = {}) {
    let root = process.cwd();

    const opts = {
        postsDir: 'resources/js/docs',
        pagesOutDir: 'resources/js/pages/docs',
        templatePath: 'resources/js/layouts/docs-layout.tsx',
        manifestPath: 'bootstrap/cache/mdx.json',
        pageExt: 'tsx',
        toSlug: (abs: string, postsAbs: string) => slugify(norm(abs).replace(norm(postsAbs) + '/', '')),
        ...user,
    };

    const abs = (p: string) => path.resolve(root, p);
    const postsAbs = () => abs(opts.postsDir);
    const outAbs = () => abs(opts.pagesOutDir);
    const tplAbs = () => abs(opts.templatePath);
    const manifestAbs = () => abs(opts.manifestPath);

    async function ensureDir(dir: string) {
        await fs.mkdir(dir, { recursive: true });
    }

    function pagePathForSlug(slug: string) {
        return norm(path.join(outAbs(), slug + '.' + opts.pageExt));
    }

    function pageSource({ slug, mdxAbs }: { slug: string; mdxAbs: string }) {
        const mdxImport = '/' + norm(path.relative(root, mdxAbs));
        return `// Auto-generated by inertia-mdx-pages. Do not edit.
// @ts-nocheck
import React from 'react'
import DocsLayout from '@/layouts/docs-layout';
import { MdxGlobalProvider } from '@/components/docs/mdx-provider'
import MDX, { frontmatter } from '${mdxImport}'

export default function Page(props) {
  return (
    <DocsLayout slug=${JSON.stringify(slug)} meta={frontmatter} {...props}>
      <MdxGlobalProvider>
        <MDX />
      </MdxGlobalProvider>
    </DocsLayout>
  )
}
`;
    }

    async function validateMdxFile(absFile: string): Promise<void> {
        try {
            const content = await fs.readFile(absFile, 'utf8');
            const { content: markdownContent } = matter(content);

            // Basic validation checks
            if (!markdownContent.trim()) {
                throw new Error(`MDX file is empty or contains only frontmatter: ${absFile}`);
            }

            // Check for common problematic patterns
            const problematicPatterns = [
                { pattern: /\{[^}]*new Date\([^)]*\)[^}]*\}/, message: 'Avoid complex Date expressions in JSX. Use simpler frontmatter access.' },
                { pattern: /\$\$[^$]*\$\$/, message: 'LaTeX math expressions may need proper escaping or math plugin configuration.' },
                {
                    pattern: /\{[^}]*\.map\([^)]*=>\s*\([^}]*\n[^}]*\}/,
                    message: 'Complex multi-line JSX expressions in map() may need to be wrapped in a component block.',
                },
            ];

            for (const { pattern, message } of problematicPatterns) {
                if (pattern.test(markdownContent)) {
                    console.warn(`âš ï¸  MDX Warning in ${absFile}: ${message}`);
                }
            }
        } catch (error) {
            throw new Error(`Failed to validate MDX file ${absFile}: ${error.message}`);
        }
    }

    async function writeOne(absFile: string) {
        try {
            await validateMdxFile(absFile);
            const slug = opts.toSlug(absFile, postsAbs());
            const dest = pagePathForSlug(slug);
            await ensureDir(path.dirname(dest));
            await fs.writeFile(dest, pageSource({ slug, mdxAbs: absFile }), 'utf8');
        } catch (error) {
            console.error(`âŒ Error processing MDX file ${absFile}:`, error.message);
            throw error;
        }
    }

    async function removeOne(absFile: string) {
        const slug = opts.toSlug(absFile, postsAbs());
        const dest = pagePathForSlug(slug);
        try {
            await fs.unlink(dest);
        } catch {
            /* ignore */
        }
    }

    async function writeManifest() {
        const pattern = norm(path.join(postsAbs(), '**/*.mdx'));
        const files = await fg(pattern);
        const items = await Promise.all(
            files.map(async (file) => {
                const raw = await fs.readFile(file, 'utf8');
                const { data, content } = matter(raw);

                // Generate table of contents from the markdown content
                const tocData = await getTableOfContents(content);
                const toc = convertTocForDocsComponent(tocData);

                return {
                    slug: opts.toSlug(file, postsAbs()),
                    meta: data ?? {},
                    toc,
                };
            }),
        );
        await ensureDir(path.dirname(manifestAbs()));
        await fs.writeFile(manifestAbs(), JSON.stringify(items, null, 2), 'utf8');
    }

    async function cleanupOrphanedPages() {
        // Find all existing generated pages
        const existingPagesPattern = norm(path.join(outAbs(), '**/*.' + opts.pageExt));
        const existingPages = await fg(existingPagesPattern);

        // Find all current MDX files and their expected page paths
        const mdxPattern = norm(path.join(postsAbs(), '**/*.mdx'));
        const mdxFiles = await fg(mdxPattern);
        const expectedPages = new Set(
            mdxFiles.map((file) => {
                const slug = opts.toSlug(file, postsAbs());
                return pagePathForSlug(slug);
            }),
        );

        // Remove orphaned pages
        const orphanedPages = existingPages.filter((page) => !expectedPages.has(norm(page)));
        await Promise.all(
            orphanedPages.map(async (page) => {
                try {
                    await fs.unlink(page);
                } catch {
                    /* ignore */
                }
            }),
        );
    }

    async function generateAll() {
        // First clean up any orphaned pages
        await cleanupOrphanedPages();

        // Then generate pages for current MDX files
        const pattern = norm(path.join(postsAbs(), '**/*.mdx'));
        const files = await fg(pattern);
        await Promise.all(files.map(writeOne));
        await writeManifest();
    }

    return {
        name: 'inertia-mdx-pages',
        // runs in BOTH dev and build
        apply: undefined,
        configResolved(cfg: any) {
            root = cfg.root;
        },
        async buildStart() {
            await generateAll();
        },
        async closeBundle() {
            // Write final manifest after production build too
            await writeManifest();
        },
        configureServer(server: any) {
            const watcher = chokidar.watch(norm(path.join(postsAbs(), '**/*.mdx')), { ignoreInitial: true });
            const onUpdate = async (file: string, kind: 'add' | 'change' | 'unlink') => {
                try {
                    console.log(`ðŸ“ MDX ${kind}: ${path.basename(file)}`);
                    if (kind === 'unlink') {
                        await removeOne(file);
                        console.log(`ðŸ—‘ï¸  Removed generated page for: ${path.basename(file)}`);
                    } else {
                        await writeOne(file);
                        console.log(`âœ… Generated page for: ${path.basename(file)}`);
                    }
                    await writeManifest();
                    server.ws.send({ type: 'full-reload' });
                } catch (error) {
                    console.error(`âŒ Failed to process MDX file ${file}:`, error.message);
                    // Still send reload to show error in browser
                    server.ws.send({ type: 'full-reload' });
                }
            };
            watcher
                .on('add', (f) => onUpdate(f, 'add'))
                .on('change', (f) => onUpdate(f, 'change'))
                .on('unlink', (f) => onUpdate(f, 'unlink'));

            const tplWatcher = chokidar.watch(tplAbs(), { ignoreInitial: true });
            tplWatcher.on('change', async () => {
                await generateAll();
                server.ws.send({ type: 'full-reload' });
            });
        },
    };
}
